---
title:  "[파이썬] 데이터 전처리(2)-분석용 데이터 탐색(5)"
date: 2020-04-01
categories: ['python']
tags: ['python', '파이썬']
---

## 1. 두개의 데이터 프레임 병합하기

##### 예제 코드

- print_df.py는 chapter 35에 명시된 코드를 사용

##### 구현 코드 1

```python
# 모듈 참조
from print_df import print_df
import pandas as pd

#-----------------------
#1) 행단위 병합
#-----------------------
df_top = pd.DataFrame({'국어':[90,82], '수학':[81, 76]}, index=['민철','철수'])
print_df(df_top)

df_middle = pd.DataFrame({'국어':[70,62], '수학':[77, 68]}, index=['영민','정수'])
print_df(df_middle)


df_bottom = pd.DataFrame({'국어':[70,88], '수학':[81, 76]}, index=['민철','태영'])

#데이터 프레임을 순서대로 병합한다.
# -> 단순히 새로 방향으로 덧붙이는 개념이므로 인덱스가 중복되는 경우도 발생한다.
# -> sort 파라미터를 생략하거나 True로 지정한 경우 컬럼 순서가 이름순으로 정렬된다.
# -> (중요) 병합되는 DataFrame간에 컬럼이 서로 다르면 sort=False 파라미터는 필수로 지정해야 함.
result = pd.concat([df_top, df_middle, df_bottom], sort=False)
print_df(result)
```

```
<class 'pandas.core.frame.DataFrame'>
(2, 2)
+------+------+------+
|      | 국어 | 수학 |
+------+------+------+
| 민철 |  90  |  81  |
| 철수 |  82  |  76  |
+------+------+------+


<class 'pandas.core.frame.DataFrame'>
(2, 2)
+------+------+------+
|      | 국어 | 수학 |
+------+------+------+
| 영민 |  70  |  77  |
| 정수 |  62  |  68  |
+------+------+------+


<class 'pandas.core.frame.DataFrame'>
(6, 2)
+------+------+------+
|      | 국어 | 수학 |
+------+------+------+
| 민철 |  90  |  81  |
| 철수 |  82  |  76  |
| 영민 |  70  |  77  |
| 정수 |  62  |  68  |
| 민철 |  70  |  81  |
| 태영 |  88  |  76  |
+------+------+------+
```
<br>

##### 구현 코드 2(1에 이어서)

```python

#--------------------
#2) 열단위 병합
#--------------------
# 샘플데이터 프레임
df_left = pd.DataFrame({'고객번호':[1001,1002,1003,1004], '이름':['둘리', '도우너', '또치', '길동']})
print_df(df_left)

df_right = pd.DataFrame({'고객번호':[1001,1002,1003,1005], '금액':[10000,20000,15000,5000]})
print_df(df_right)

#공통 컬럼인 고객번호를 기준으로 데이터를 찾아서 병합한다.
# 이  때 기본적으로 양쪽 데이터프레임에 모두 존재하는 데이터만 보여준다.
# -> Database의 Inner Join과 같은 개념
# 병합시 제외되는 항목들
# -> df_left의 고객번호 1004번 데이터는 df_right의 고객 번호 컬럼과 겹치지 않는다.
# -> df_right의 고객번호 1005번 데이터는 df_left의 고객번호 컬럼과 겹치지 않는다.
result = pd.merge(df_left,df_right)
print_df(result)

#how='left' 파라미터는 첫 번째 DataFrame의 모든 데이터를 보여준다.
# -> 두 번째 Dataframe은 첫 번째 Dataframe과 공동 컬럼의 값이 일치하는 항목만 보여준다.
# -> df_right의 고객번호 1005은 df_left에 존재하지 않기 때문에 병합되지 않는다.
# -> Database의 Left Outer Join과 같은 개념
result = pd.merge(df_left,df_right, how='left')
print_df(result)

#how='right' 파라미터는 두 번째 DataFrame의 모든 데이터를 보여준다.
# -> 첫 번째 DataFrame은 두 번째 DataFrame과 공동 컬럼의 값이 일치하는 항목만 보여준다.
# -> df1의 고객번호 1004는 df_left에 존재하지 않기 때문에 병합되지 않는다.
# -> Database의 Right Outer Join과 같은 개념
result = pd.merge(df_left,df_right, how='right')
print_df(result)

#how='outer' 파라미터를 추가하면 공통 컬럼의 값이 한쪽에만 있어도 데이터를 보여준다.
# -> 양 쪽 데이터 프레임의 모든 데이터를 병합한다.
# -> Database의 Full Outer Join과 같은 개념
result = pd.merge(df_left,df_right, how='outer')
print_df(result)
```

```
<class 'pandas.core.frame.DataFrame'>
(4, 2)
+---+----------+--------+
|   | 고객번호 |  이름  |
+---+----------+--------+
| 0 |   1001   |  둘리  |
| 1 |   1002   | 도우너 |
| 2 |   1003   |  또치  |
| 3 |   1004   |  길동  |
+---+----------+--------+


<class 'pandas.core.frame.DataFrame'>
(4, 2)
+---+----------+-------+
|   | 고객번호 |  금액 |
+---+----------+-------+
| 0 |   1001   | 10000 |
| 1 |   1002   | 20000 |
| 2 |   1003   | 15000 |
| 3 |   1005   |  5000 |
+---+----------+-------+


<class 'pandas.core.frame.DataFrame'>
(3, 3)
+---+----------+--------+-------+
|   | 고객번호 |  이름  |  금액 |
+---+----------+--------+-------+
| 0 |   1001   |  둘리  | 10000 |
| 1 |   1002   | 도우너 | 20000 |
| 2 |   1003   |  또치  | 15000 |
+---+----------+--------+-------+


<class 'pandas.core.frame.DataFrame'>
(4, 3)
+---+----------+--------+---------+
|   | 고객번호 |  이름  |   금액  |
+---+----------+--------+---------+
| 0 |   1001   |  둘리  | 10000.0 |
| 1 |   1002   | 도우너 | 20000.0 |
| 2 |   1003   |  또치  | 15000.0 |
| 3 |   1004   |  길동  |   nan   |
+---+----------+--------+---------+


<class 'pandas.core.frame.DataFrame'>
(4, 3)
+---+----------+--------+-------+
|   | 고객번호 |  이름  |  금액 |
+---+----------+--------+-------+
| 0 |   1001   |  둘리  | 10000 |
| 1 |   1002   | 도우너 | 20000 |
| 2 |   1003   |  또치  | 15000 |
| 3 |   1005   |  nan   |  5000 |
+---+----------+--------+-------+


<class 'pandas.core.frame.DataFrame'>
(5, 3)
+---+----------+--------+---------+
|   | 고객번호 |  이름  |   금액  |
+---+----------+--------+---------+
| 0 |   1001   |  둘리  | 10000.0 |
| 1 |   1002   | 도우너 | 20000.0 |
| 2 |   1003   |  또치  | 15000.0 |
| 3 |   1004   |  길동  |   nan   |
| 4 |   1005   |  nan   |  5000.0 |
+---+----------+--------+---------+
```
<br>

##### 구현 코드 3(2에 이어서)

```python

#만약 양쪽 데이터프레임의 공통컬럼에 중복 데이터가 여러개 있는 경우
#모든 경우의 수를 따져서 조합을 만들어 낸다.
df_left = pd.DataFrame({'아이디':['hello', 'world','python', 'hello'],'결제금액':[14000,13000, 15000, 13000]})
print_df(df_left)

df_right = pd.DataFrame({'아이디':['hello', 'python', 'python', 'world'],'적립금':[300, 500, 100, 200]})

print_df(df_right)

result=pd.merge(df_left, df_right)
print_df(result)
```

```


<class 'pandas.core.frame.DataFrame'>
(4, 2)
+---+--------+----------+
|   | 아이디 | 결제금액 |
+---+--------+----------+
| 0 | hello  |  14000   |
| 1 | world  |  13000   |
| 2 | python |  15000   |
| 3 | hello  |  13000   |
+---+--------+----------+


<class 'pandas.core.frame.DataFrame'>
(4, 2)
+---+--------+--------+
|   | 아이디 | 적립금 |
+---+--------+--------+
| 0 | hello  |  300   |
| 1 | python |  500   |
| 2 | python |  100   |
| 3 | world  |  200   |
+---+--------+--------+


<class 'pandas.core.frame.DataFrame'>
(5, 3)
+---+--------+----------+--------+
|   | 아이디 | 결제금액 | 적립금 |
+---+--------+----------+--------+
| 0 | hello  |  14000   |  300   |
| 1 | hello  |  13000   |  300   |
| 2 | world  |  13000   |  200   |
| 3 | python |  15000   |  500   |
| 4 | python |  15000   |  100   |
+---+--------+----------+--------+
```
<br>

##### 구현 코드 4(3에 이어서)

```python
# 두 데이터 프레임에서 이름이 같은 열은 모두 Key(컬럼 이름)가 된다.
# 만약 이름이 같지만 데이터 병합을 하면 안되는 열이 있다면 on 인수로 기준열을 명시해야 한다.
df_left = pd.DataFrame({'고객명':['민수', '수영'], '날짜':['2018-01-01', '2018-01-01'], '데이터':['20000','100000']})
print_df(df_left)

#df_left의 '데이터'는 금액을 의미하지만 df_right의 데이터는 나이를 의미하므로 병합되어서는 안된다.
df_right = pd.DataFrame({'고객명':['민수','수영'],'데이터':['21세','20세']})
print_df(df_right)

#기준 열이 아니면서 이름이 같는 열에는 _x 또는 _y와 같은 접미사가 붙는다.
result = pd.merge(df_left, df_right, on='고객명')
print_df(result)
```

```
<class 'pandas.core.frame.DataFrame'>
(2, 3)
+---+--------+------------+--------+
|   | 고객명 |    날짜    | 데이터 |
+---+--------+------------+--------+
| 0 |  민수  | 2018-01-01 | 20000  |
| 1 |  수영  | 2018-01-01 | 100000 |
+---+--------+------------+--------+


<class 'pandas.core.frame.DataFrame'>
(2, 2)
+---+--------+--------+
|   | 고객명 | 데이터 |
+---+--------+--------+
| 0 |  민수  |  21세  |
| 1 |  수영  |  20세  |
+---+--------+--------+


<class 'pandas.core.frame.DataFrame'>
(2, 4)
+---+--------+------------+----------+----------+
|   | 고객명 |    날짜    | 데이터_x | 데이터_y |
+---+--------+------------+----------+----------+
| 0 |  민수  | 2018-01-01 |  20000   |   21세   |
| 1 |  수영  | 2018-01-01 |  100000  |   20세   |
+---+--------+------------+----------+----------+
```
<br>

##### 구현 코드 5(4에 이어서)

```python
# 두  데이터 프레임의 컬럼이름이 모두 다르면
# left_on, right_on 파라미터를 사용하여 병합의 기준이 되는 열 이름을 명시해야 한다.
df_left = pd.DataFrame({'이름':['영희', '철수'],'국어':[87, 91]})
print_df(df_left)

df_right = pd.DataFrame({'성명':['영희','철수'],'영어':[90,82]})
print_df(df_right)

#왼쪽의 이름 컬럼과 오른쪽의 성명 컬럼이 같은 데이터를 병합하라는 의미
result=pd.merge(df_left,df_right, left_on=['이름'],right_on=['성명'])
print_df(result)
```

```
<class 'pandas.core.frame.DataFrame'>
(2, 2)
+---+------+------+
|   | 이름 | 국어 |
+---+------+------+
| 0 | 영희 |  87  |
| 1 | 철수 |  91  |
+---+------+------+


<class 'pandas.core.frame.DataFrame'>
(2, 2)
+---+------+------+
|   | 성명 | 영어 |
+---+------+------+
| 0 | 영희 |  90  |
| 1 | 철수 |  82  |
+---+------+------+


<class 'pandas.core.frame.DataFrame'>
(2, 4)
+---+------+------+------+------+
|   | 이름 | 국어 | 성명 | 영어 |
+---+------+------+------+------+
| 0 | 영희 |  87  | 영희 |  90  |
| 1 | 철수 |  91  | 철수 |  82  |
+---+------+------+------+------+
```
<br>

##### 구현 코드 6(5에 이어서)

```python
#왼쪽 데이터프레임의 이름 열과 오른쪽 데이터 프레임의 인덱스가
#같은 데이터끼리 병합하기
df_left=pd.DataFrame({'이름':['영희','철수'],'국어':[87,91]})
print_df(df_left)

df_right=pd.DataFrame({'영어':[90,82]}, index=['영희', '철수'])
print_df(df_right)

#왼쪽의 데이터프레임의 기준이 될 컬럼이름을 left_on 파라미터로 명시
#오른쪽의 데이터 프레임에서는 index를 기준으로 하기 위해 right_index=True 명시
result = pd.merge(df_left, df_right, left_on=['이름'], right_index=True)
print_df(result)
```

```
<class 'pandas.core.frame.DataFrame'>
(2, 2)
+---+------+------+
|   | 이름 | 국어 |
+---+------+------+
| 0 | 영희 |  87  |
| 1 | 철수 |  91  |
+---+------+------+


<class 'pandas.core.frame.DataFrame'>
(2, 1)
+------+------+
|      | 영어 |
+------+------+
| 영희 |  90  |
| 철수 |  82  |
+------+------+


<class 'pandas.core.frame.DataFrame'>
(2, 3)
+---+------+------+------+
|   | 이름 | 국어 | 영어 |
+---+------+------+------+
| 0 | 영희 |  87  |  90  |
| 1 | 철수 |  91  |  82  |
+---+------+------+------+
```
<br>

##### 구현 코드 7(6에 이어서)

```python
# 학생의 이름을 인덱스로 ㄱ자는 두 데이터 프레임
df_left = pd.DataFrame({'수학':[90,82]}, index=['민철', '봉구'])
print_df(df_left)

df_right = pd.DataFrame({'국어':[90,82]}, index=['민철', '철수'])
print_df(df_right)

#양쪽 데이터 프레임의 index가 같은 행끼리 병합 (inner)
result1 = pd.merge(df_left,df_right, left_index=True, right_index=True)
print_df(result1)

#양 쪽 데이터 프레임의 index가 같은 행끼리 병합(full outer)
result2 = pd.merge(df_left,df_right, left_index=True, right_index=True, how='outer')
print_df(result2)
```

```
<class 'pandas.core.frame.DataFrame'>
(2, 1)
+------+------+
|      | 수학 |
+------+------+
| 민철 |  90  |
| 봉구 |  82  |
+------+------+


<class 'pandas.core.frame.DataFrame'>
(2, 1)
+------+------+
|      | 국어 |
+------+------+
| 민철 |  90  |
| 철수 |  82  |
+------+------+


<class 'pandas.core.frame.DataFrame'>
(1, 2)
+------+------+------+
|      | 수학 | 국어 |
+------+------+------+
| 민철 |  90  |  90  |
+------+------+------+


<class 'pandas.core.frame.DataFrame'>
(3, 2)
+------+------+------+
|      | 수학 | 국어 |
+------+------+------+
| 민철 | 90.0 | 90.0 |
| 봉구 | 82.0 | nan  |
| 철수 | nan  | 82.0 |
+------+------+------+
```
<br>

## 2. 피벗 테이블 + 그룹 분석

### 1) 피벗(Pivot) 테이블 

데이터 열(column) 중 두개의 열을 각각 행 인덱스, 열 인덱스로 사용하여 데이터를 재배치 한 것을 말한다.

### 2) 피벗 테이블의 조건

행과 열을 구성 했을 때 데이터가 단 하나만 검색되어야 한다.

##### 예제코드

sampel.py와 print_df.py는 chapter35에 명시된 코드이다.

##### 구현코드 1

```python
#모듈 참조
from print_df import print_df
from pandas import DataFrame
from matplotlib import pyplot
import numpy

#데이터를 참조하여 데이터 프레임 만들기
from sample import city_people
df = DataFrame(city_people)
print_df(df)

#각 도시별 연도에 따른 인구수
pv1 = df.pivot('도시', '연도', '인구')
print_df(pv1)
```

```
<class 'pandas.core.frame.DataFrame'>
(8, 4)
+---+------+------+---------+--------+
|   | 도시 | 연도 |   인구  |  지역  |
+---+------+------+---------+--------+
| 0 | 서울 | 2015 | 9904312 | 수도권 |
| 1 | 서울 | 2010 | 9631482 | 수도권 |
| 2 | 서울 | 2005 | 9762546 | 수도권 |
| 3 | 부산 | 2015 | 3448737 | 경상권 |
| 4 | 부산 | 2010 | 3393191 | 경상권 |
| 5 | 부산 | 2005 | 3512547 | 경상권 |
| 6 | 인천 | 2015 | 2890451 | 수도권 |
| 7 | 인천 | 2010 | 2632035 | 수도권 |
+---+------+------+---------+--------+


<class 'pandas.core.frame.DataFrame'>
(3, 3)
+------+-----------+-----------+-----------+
|      |    2005   |    2010   |    2015   |
+------+-----------+-----------+-----------+
| 부산 | 3512547.0 | 3393191.0 | 3448737.0 |
| 서울 | 9762546.0 | 9631482.0 | 9904312.0 |
| 인천 |    nan    | 2632035.0 | 2890451.0 |
+------+-----------+-----------+-----------+
```
<br>

### 3) 그룹 분석

#### [1] 특정 조건에 맞는 데이터가 하나 이상의 그룹을 이루는 경우

- 그룹 분석은 피벗 테이블과 달리 키(key)에 의해 결정되는 데이터가 많을 수 있다.

- 주어진 연산을 통해 그룹 데이터의 대표값을 정한다.

- Pandas의 groupby 명령과 그룹 연산 메서드를 이용하여 그룹 분석을 한다.

#### [2] 그룹 연산 방법

- 분석하려는 시리즈(Series)나 데이터 프레임에 groupby()함수를 호출하여 그룹을 만든다.

- 그룹 객체에 대해 그룹 연산을 수행한다.

#### [3] 그룹 연산 종류

|함수명|설명|
|:--:|:--|
|size, count| 그룹 데이터의 개수|
|mean, median, min, max| 평균, 중앙값, 최소, 최대|
|sum, prod, std, var, quantile | 그룹 데이터의 합계, 곱, 표준편차, 분산, 사분위 수|
| first, last| 그룹 데이터 중 가장 첫번째 데이터와 가장 나중 데이터|

##### 예제코드

##### 구현코드 2(1번에 이어서)

```python
#지역별 그룹 분석
df1 = df.filter(['지역', '인구수'])
a1 = df.groupby(df1['지역']).sum()
print_df(a1)

#연도별 그룹 분석
df2 = df.filter(['연도','인구수'])
a2 = df.groupby(df2['연도']).sum()
print_df(a2)

#두 개 이상의 열에 대한 그룹 분석
df3 = df.filter(['지역', '연도', '인구수'])
a3 = df.groupby([df['지역'],df['연도']]).mean()
print_df(a3)
```

```
<class 'pandas.core.frame.DataFrame'>
(2, 1)
+--------+----------+
|        |   인구   |
+--------+----------+
| 경상권 | 10354475 |
| 수도권 | 34820826 |
+--------+----------+


<class 'pandas.core.frame.DataFrame'>
(3, 1)
+------+----------+
|      |   인구   |
+------+----------+
| 2005 | 13275093 |
| 2010 | 15656708 |
| 2015 | 16243500 |
+------+----------+


<class 'pandas.core.frame.DataFrame'>
(6, 1)
+--------------------+-----------+
|                    |    인구   |
+--------------------+-----------+
| ('경상권', '2005') | 3512547.0 |
| ('경상권', '2010') | 3393191.0 |
| ('경상권', '2015') | 3448737.0 |
| ('수도권', '2005') | 9762546.0 |
| ('수도권', '2010') | 6131758.5 |
| ('수도권', '2015') | 6397381.5 |
+--------------------+-----------+
```

참조 : 호쌤의 교육자료, (<https://blog.itpaper.co.kr/>)